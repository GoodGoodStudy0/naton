


(function(a,b){



	// jQuery WipeTouch 1.2.0
// ------------------------------------------------------------------------
//
// Developed and maintained by Igor Ramadas
// http://aboutigor.com
// http://devv.com
//
// USAGE
// ------------------------------------------------------------------------
//
// $(selector).wipetouch(config);
//
// The wipe events should expect the result object with the following properties:
// speed - the wipe speed from 1 to 5
// x - how many pixels moved on the horizontal axis
// y - how many pixels moved on the vertical axis
// source - the element which triggered the wipe gesture
//
// EXAMPLE
//		$(document).wipetouch({
//			allowDiagonal: true,
//			wipeLeft: function(result) { alert("Left on speed " + result.speed) },
//			wipeTopLeft: function(result) { alert("Top left on speed " + result.speed) },
//			wipeBottomLeft: function(result) { alert("Bottom left on speed " + result.speed) }
//		});
//
//
// More details at http://wipetouch.codeplex.com/
//
// CHANGE LOG
// ------------------------------------------------------------------------
// 1.2.0
// - New: wipeMove event, triggered while moving the mouse/finger.
// - New: added "source" to the result object.
// - Bug fix: sometimes vertical wipe events would not trigger correctly.
// - Bug fix: improved tapToClick handler.
// - General code refactoring.
// - Windows Phone 7 is not supported, yet! Its behaviour is completely broken and would require some special tricks to make it work. Maybe in the future...
//
// 1.1.0
// - New: tapToClick, if true will identify taps and and trigger a click on the touched element. Default is false.
// - Changed: events wipeBottom*** and wipeTop*** renamed to wipeDown*** and wipeUp***.
// - Changed: better touch speed calculation (was always too fast before).
// - Changed: speed will be an integer now (instead of float).
// - Changed: better wipe detection (if Y movement is more than X, do a vertical wipe instead of horizontal).
// - Bug fix: added preventDefault to touchStart and touchEnd internal events (this was missing).
// - Other general tweaks to the code.
//
// The minified version of WipeTouch can be generated using Jasc: http://jasc.codeplex.com

	jQuery.fn.wipetouch=function(settings)
{var config={moveX:40,moveY:40,tapToClick:false,preventDefault:true,allowDiagonal:false,wipeLeft:false,wipeRight:false,wipeUp:false,wipeDown:false,wipeUpLeft:false,wipeDownLeft:false,wipeUpRight:false,wipeDownRight:false,wipeMove:false,wipeTopLeft:false,wipeBottomLeft:false,wipeTopRight:false,wipeBottomRight:false};if(settings)
{jQuery.extend(config,settings);}
this.each(function()
{var startX;var startY;var startDate=false;var curX;var curY;var isMoving=false;var touchedElement=false;var useMouseEvents=false;var clickEvent=false;function onTouchStart(e)
{var start=useMouseEvents||(e.originalEvent.touches&&e.originalEvent.touches.length>0);if(!isMoving&&start)
{if(config.preventDefault)
{e.preventDefault();}
if(config.allowDiagonal)
{if(!config.wipeDownLeft)
{config.wipeDownLeft=config.wipeBottomLeft;}
if(!config.wipeDownRight)
{config.wipeDownRight=config.wipeBottomRight;}
if(!config.wipeUpLeft)
{config.wipeUpLeft=config.wipeTopLeft;}
if(!config.wipeUpRight)
{config.wipeUpRight=config.wipeTopRight;}}
if(useMouseEvents)
{startX=e.pageX;startY=e.pageY;jQuery(this).bind("mousemove",onTouchMove);jQuery(this).one("mouseup",onTouchEnd);}
else
{startX=e.originalEvent.touches[0].pageX;startY=e.originalEvent.touches[0].pageY;jQuery(this).bind("touchmove",onTouchMove);}
startDate=new Date().getTime();curX=startX;curY=startY;isMoving=true;touchedElement=jQuery(e.target);}}
function onTouchEnd(e)
{if(config.preventDefault)
{e.preventDefault();}
if(useMouseEvents)
{jQuery(this).unbind("mousemove",onTouchMove);}
else
{jQuery(this).unbind("touchmove",onTouchMove);}
if(isMoving)
{touchCalculate(e);}
else
{resetTouch();}}
function onTouchMove(e)
{if(config.preventDefault)
{e.preventDefault();}
if(useMouseEvents&&!isMoving)
{onTouchStart(e);}
if(isMoving)
{if(useMouseEvents)
{curX=e.pageX;curY=e.pageY;}
else
{curX=e.originalEvent.touches[0].pageX;curY=e.originalEvent.touches[0].pageY;}
if(config.wipeMove)
{triggerEvent(config.wipeMove,{curX:curX,curY:curY});}}}
function touchCalculate(e)
{var endDate=new Date().getTime();var ms=startDate-endDate;var x=curX;var y=curY;var dx=x-startX;var dy=y-startY;var ax=Math.abs(dx);var ay=Math.abs(dy);if(ax<15&&ay<15&&ms<100)
{clickEvent=false;if(config.preventDefault)
{resetTouch();touchedElement.trigger("click");return;}}
else if(useMouseEvents)
{var evts=touchedElement.data("events");if(evts)
{var clicks=evts.click;if(clicks&&clicks.length>0)
{jQuery.each(clicks,function(i,f)
{clickEvent=f;return;});touchedElement.unbind("click");}}}
var toright=dx>0;var tobottom=dy>0;var s=((ax+ay)*60)/((ms)/6*(ms));if(s<1)s=1;if(s>5)s=5;var result={speed:parseInt(s),x:ax,y:ay,source:touchedElement};if(ax>=config.moveX)
{if(config.allowDiagonal&&ay>=config.moveY)
{if(toright&&tobottom)
{triggerEvent(config.wipeDownRight,result);}
else if(toright&&!tobottom)
{triggerEvent(config.wipeUpRight,result);}
else if(!toright&&tobottom)
{triggerEvent(config.wipeDownLeft,result);}
else
{triggerEvent(config.wipeUpLeft,result);}}
else if(ax>=ay)
{if(toright)
{triggerEvent(config.wipeRight,result);}
else
{triggerEvent(config.wipeLeft,result);}}}
else if(ay>=config.moveY&&ay>ax)
{if(tobottom)
{triggerEvent(config.wipeDown,result);}
else
{triggerEvent(config.wipeUp,result);}}
resetTouch();}
function resetTouch()
{startX=false;startY=false;startDate=false;isMoving=false;if(clickEvent)
{window.setTimeout(function()
{touchedElement.bind("click",clickEvent);clickEvent=false;},50);}}
function triggerEvent(wipeEvent,result)
{if(wipeEvent)
{wipeEvent(result);}}
if("ontouchstart"in document.documentElement)
{jQuery(this).bind("touchstart",onTouchStart);jQuery(this).bind("touchend",onTouchEnd);}
else
{useMouseEvents=true;jQuery(this).bind("mousedown",onTouchStart);jQuery(this).bind("mouseout",onTouchEnd);}});return this;};

})(jQuery)

